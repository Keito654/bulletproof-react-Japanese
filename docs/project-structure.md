# 🗄️ プロジェクトの構成

ほとんどのコードは`src`フォルダに入っており、次のような構成になります：

```sh
src
|
+-- app               # アプリケーション層を含む:
|   |                 # このフォルダは使っているメタフレームワークによって異なるかもしれません
|   +-- routes        # アプリケーションのルートフォルダ / ページフォルダにもなる
|   +-- app.tsx       # アプリケーションのメインコンポーネント
|   +-- provider.tsx  # さまざまなグローバルプロバイダーでアプリケーション全体をラップする、アプリケーションプロバイダー - 使っているメタフレームワークによって異なるかもしれません
|   +-- router.tsx    # アプリケーションのルーティング設定
+-- assets            # 画像、フォントファイルなどの静的ファイルを全て含むアセットフォルダ
|
+-- components        # アプリケーション全体を通して使われる共通コンポーネント
|
+-- config            # グローバル設定やエクスポートされた環境変数など
|
+-- features          # 機能ベースのモジュール
|
+-- hooks             # アプリケーション全体を通して使われる共通hooks
|
+-- lib               # アプリケーション用に作成したライブラリ
|
+-- stores            # グローバルな状態のストア
|
+-- testing           # テストのためのユーティリティファイルやモックファイル
|
+-- types             # アプリケーション全体で使う型
|
+-- utils             # 共通ユーティリティ関数
```

拡張と維持を簡単にするため、ほとんどのコードをfeaturesフォルダにまとめます。各featureフォルダはその機能固有のコードが含まれ、きちんと分割されている必要があります。このアプローチは機能に関連するコードが共通コンポーネントに混ざるのを防ぎ、フラットなフォルダに多くのファイルが入っている構成と比べコードベースの維持管理をシンプルにします。この手法を採用することで、アプリケーションのアーキテクチャにおける共同作業の効率性、可読性、拡張性を強化できます。

１つのfeatureフォルダは次の構成を取ります:

```sh
src/features/awesome-feature
|
+-- api         # APIリクエストの定義やこの機能に関連するAPIのhooks
|
+-- assets      # この機能で利用する静的ファイルを全て含むアセットフォルダ
|
+-- components  # 機能に関連するコンポーネント
|
+-- hooks       # 機能に関連するhooks
|
+-- stores      # 機能に関連する状態のストア
|
+-- types       # この機能の中で利用するtypescriptの型
|
+-- utils       # この機能で利用するユーティリティ関数
```

注意: これらのフォルダ全てを各featureフォルダに作る必要はありません。機能に必要なもののみ含めます。

場合によっては、APIコールをfeaturesフォルダの外、全てのAPIコールが定義されている専用の`api`フォルダに保存する方が実用的かもしれません。これは、複数の機能間で多くのAPIコールを共有する場合に便利です。

かつては、featureフォルダにある全てのファイルをエクスポートするバレルファイルの利用が推奨されていました。しかし、バレルファイルはViteがツリーシェイキングを行う際に問題が発生したり、パフォーマンスの問題を起こす原因となります。そのため、ファイルを直接インポートすることを推奨します。

featureフォルダ間でインポートを行うのは得策ではありません。代わりに、アプリケーションレベルで異なるfeatureを構成してください。この方法により、各機能が独立していることが保証され、コードベースの複雑さを軽減できます。

feature間のインポートを禁止するため、ESLintを利用できます:

```js
'import/no-restricted-paths': [
    'error',
    {
        zones: [
            // feature間のインポートを無効化する:
            // 例えば、src/features/discussionsはfrom src/features/commentsをインポートすべきではない、など。
            {
                target: './src/features/auth',
                from: './src/features',
                except: ['./auth'],
            },
            {
                target: './src/features/comments',
                from: './src/features',
                except: ['./comments'],
            },
            {
                target: './src/features/discussions',
                from: './src/features',
                except: ['./discussions'],
            },
            {
                target: './src/features/teams',
                from: './src/features',
                except: ['./teams'],
            },
            {
                target: './src/features/users',
                from: './src/features',
                except: ['./users'],
            },

            // 続き...
        ],
    },
],
```

一方向のコードベースアーキテクチャを強制することもできます。これは、コードは共通部品からアプリケーションに向かって(共通→機能→アプリケーション)のように一方通行で流れることを意味します。これは、コードベースをより予測可能にし、理解を容易にするため、従うべき良い習慣です。

![一方向のコードベース](./assets/unidirectional-codebase.png)

ご覧の通り、共通部品はコードベースのいろいろな部品で使われています。しかし、featuresは共通部品のみをインポートできます。また、appは共通部品とfeaturesをインポートできます。

これを強制するためのESLintのルール:

```js
'import/no-restricted-paths': [
    'error',
    {
    zones: [
        // 省略したルール...

        // コードベースを一方向に強制する:
        // 例えば、src/appはsrc/featuresをインポートできますが、逆はできません。
        {
            target: './src/features',
            from: './src/app',
        },

        // 例えば、src/featuresとsrc/appはこれら共通部品をインポートできますが、逆はできません。
        {
            target: [
                './src/components',
                './src/hooks',
                './src/lib',
                './src/types',
                './src/utils',
            ],
            from: ['./src/features', './src/app'],
        },
    ],
    },
],
```

この例に従うと、コードベースがよくまとまり、拡張性や保守性に優れたものにできます。これは、あなたとあなたのチームの作業をより効率的・効果的にするのを助けるでしょう。
このアプローチはNext.js, Remix，React Nativeで構築されたアプリケーションに同様のアーキテクチャを適用することも容易になります。
