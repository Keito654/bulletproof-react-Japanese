# ⚙️ プロジェクト標準

プロジェクト基準を施行することはReactアプリケーションのコード品質、一貫性、スケーラビリティを維持する上で重要です。一連のベストプラクティスを確立し遵守することで、開発者はコードベースがクリーンで、整理されていて、維持しやすいように保つことができます。

#### ESLint

ESLintは有用なJavaScriptのリントツールとして機能します。これは開発者がコード品質を維持し、コーディング規約を守れるよう手助けしてくれます。`.eslintrc.js`ファイルにルールを設定することで、普遍的なエラーを特定・防止し、コードの正確性を確保し、コードベース全体の一貫性向上を促進します。このアプローチはミスを簡単に見つけるだけでなく、コーディング方法を統一するよう強制し、コードの全体的な品質や可読性を強化することもできます。

[ESLintの設定のサンプルコード](../apps/react-vite/.eslintrc.cjs)

#### Prettier

Prettierはプロジェクト内で一貫したコードフォーマットを維持するのに役立つツールです。IDEの"format on save(保存時にフォーマット)"を有効にすることで、設定ファイル`.prettierrc`に書かれたルールに従って、コードが自動的にフォーマットされます。これを行うことで、コードベース間のコードスタイルを統一し、コードの問題について役立つフィードバックを提供してくれます。もし自動的なフォーマットが失敗した場合、隠れた構文エラーがあるという警告です。さらに、PrettierはESLitと統合することも可能でき、開発プロセスを通してコードフォーマットとコーディング規約の確保を効率的に行うことができます。

[Prettierの設定のサンプルコード](../apps/react-vite/.prettierrc)

#### TypeScript

ESLintはJavaScriptの言語に関するバグを発見するのに効果的です。しかし、JavaScriptの動的な性質により、特に複雑なプロジェクトにおいてESLintは全ての実行データの問題を捕らえることができません。これに対処するため、TypeScriptの利用を推奨します。TypeScriptは大規模なリファクタリング作業中に見落とされがちな問題を特定するうえで非常に役立ちます。リファクタリングの際、第一に型宣言を更新することを優先し、その後プロジェクトのTypeScriptのエラーを解決します。重要な点として、TypeScriptはビルド時に型チェックを実行し開発の信頼性を高めてくれますが、実行時のエラーを防ぐわけではないことに注意が必要です。こちらは[TypeScriptとReactを使った素晴らしい資料です](https://react-typescript-cheatsheet.netlify.app/)。

#### Husky

Huskyはワークフローの中でgit hooksを実装・実行する素晴らしいツールです。Huskyを活用しコミット前にコードの検証を行うことで、コードを高水準に保ち、リポジトリにエラーがあるコードをコミットしないようにすることができます。Huskyはコードのプッシュを許可する前に、リンティング、コードフォーマット、型チェックなど様々なタスクを実行できます。こちらで[設定方法をチェックしてください](https://typicode.github.io/husky/#/?id=usage)。

#### 絶対パスによるインポート

絶対パスによるインポートは常に設定し利用するべきです。なぜなら、`../../../component`のようなややこしいインポートを避けることができるからです。また、ファイルの移動を簡単にしてくれます。どこにファイルを移動しても、インポート文が壊れることはありません。ここに設定方法を記載します:

JavaScriptプロジェクト (`jsconfig.json`) :

```json
"compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
```

TypeScriptプロジェクト (`tsconfig.json`) :

```json
"compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
```

もちろん、個々のフォルダにそれぞれのパスを定義することも可能です（例えば、`@components`, `@hooks`など）。しかし、`@/*`は短く、複数のパスの設定を行う必要がありません。また、他の依存モジュールのパスとは異なるため、何が`node_modules`からインポートされており、何が自分たちのソースフォルダから来ているのか混乱することがありません。これは`src`フォルダにあるものはすべて`@`でアクセスできることを意味します。例えば`src/components/my-component`内にあるファイルにアクセスする際、`../../../components/my-component`と書く代わりに`@/components/my-component`と書くことができます。

#### ファイルの命名規則

プロジェクトで、ファイルやフォルダの命名規則を強制させることもできます。例えば、すべてのファイルはケバブケースで命名されるようにする、ということが可能です。これによりコードベースの一貫性が保たれ、ナビゲートが簡単になります。

強制するには、ESLintを利用します:

```js
'check-file/filename-naming-convention': [
  'error',
  {
      '**/*.{ts,tsx}': 'KEBAB_CASE',
  },
  {
      // babel.config.jsやsmoke.spec.tsのようなファイル名をサポートするため、名前の中間にある拡張子を無視する
      ignoreMiddleExtensions: true,
  },
],
'check-file/folder-naming-convention': [
  'error',
  {
    // _tests_を除く、srcにあるすべてのフォルダの前をケバブケースにする
    'src/**/!(__tests__)': 'KEBAB_CASE',
  },
],
```
